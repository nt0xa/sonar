// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package database

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
)

type DNSRecordType string

const (
	DNSRecordTypeA     DNSRecordType = "A"
	DNSRecordTypeAAAA  DNSRecordType = "AAAA"
	DNSRecordTypeMX    DNSRecordType = "MX"
	DNSRecordTypeTXT   DNSRecordType = "TXT"
	DNSRecordTypeCNAME DNSRecordType = "CNAME"
	DNSRecordTypeNS    DNSRecordType = "NS"
	DNSRecordTypeCAA   DNSRecordType = "CAA"
)

func (e *DNSRecordType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DNSRecordType(s)
	case string:
		*e = DNSRecordType(s)
	default:
		return fmt.Errorf("unsupported scan type for DNSRecordType: %T", src)
	}
	return nil
}

type NullDNSRecordType struct {
	DNSRecordType DNSRecordType
	Valid         bool // Valid is true if DNSRecordType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDNSRecordType) Scan(value interface{}) error {
	if value == nil {
		ns.DNSRecordType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DNSRecordType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDNSRecordType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DNSRecordType), nil
}

func AllDNSRecordTypeValues() []DNSRecordType {
	return []DNSRecordType{
		DNSRecordTypeA,
		DNSRecordTypeAAAA,
		DNSRecordTypeMX,
		DNSRecordTypeTXT,
		DNSRecordTypeCNAME,
		DNSRecordTypeNS,
		DNSRecordTypeCAA,
	}
}

type DNSStrategy string

const (
	DNSStrategyAll        DNSStrategy = "all"
	DNSStrategyRoundRobin DNSStrategy = "round-robin"
	DNSStrategyRebind     DNSStrategy = "rebind"
)

func (e *DNSStrategy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DNSStrategy(s)
	case string:
		*e = DNSStrategy(s)
	default:
		return fmt.Errorf("unsupported scan type for DNSStrategy: %T", src)
	}
	return nil
}

type NullDNSStrategy struct {
	DNSStrategy DNSStrategy
	Valid       bool // Valid is true if DNSStrategy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDNSStrategy) Scan(value interface{}) error {
	if value == nil {
		ns.DNSStrategy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DNSStrategy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDNSStrategy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DNSStrategy), nil
}

func AllDNSStrategyValues() []DNSStrategy {
	return []DNSStrategy{
		DNSStrategyAll,
		DNSStrategyRoundRobin,
		DNSStrategyRebind,
	}
}

type DNSRecord struct {
	ID             *int64        `db:"id"`
	PayloadID      int64         `db:"payload_id"`
	Name           string        `db:"name"`
	Type           DNSRecordType `db:"type"`
	TTL            int           `db:"ttl"`
	Values         []string      `db:"values"`
	Strategy       DNSStrategy   `db:"strategy"`
	LastAnswer     []string      `db:"last_answer"`
	LastAccessedAt *time.Time    `db:"last_accessed_at"`
	CreatedAt      time.Time     `db:"created_at"`
	Index          int           `db:"index"`
}

type Event struct {
	ID         int64      `db:"id"`
	PayloadID  int64      `db:"payload_id"`
	Protocol   string     `db:"protocol"`
	RW         []byte     `db:"rw"`
	R          []byte     `db:"r"`
	W          []byte     `db:"w"`
	Meta       EventsMeta `db:"meta"`
	RemoteAddr string     `db:"remote_addr"`
	ReceivedAt time.Time  `db:"received_at"`
	CreatedAt  time.Time  `db:"created_at"`
	UUID       uuid.UUID  `db:"uuid"`
}

type HTTPRoute struct {
	ID        int64       `db:"id"`
	PayloadID int64       `db:"payload_id"`
	Method    string      `db:"method"`
	Path      string      `db:"path"`
	Code      int         `db:"code"`
	Headers   HTTPHeaders `db:"headers"`
	Body      []byte      `db:"body"`
	IsDynamic bool        `db:"is_dynamic"`
	CreatedAt time.Time   `db:"created_at"`
	Index     int         `db:"index"`
}

type Payload struct {
	ID              int64     `db:"id"`
	UserID          int64     `db:"user_id"`
	Subdomain       string    `db:"subdomain"`
	Name            string    `db:"name"`
	CreatedAt       time.Time `db:"created_at"`
	NotifyProtocols []string  `db:"notify_protocols"`
	StoreEvents     bool      `db:"store_events"`
}

type User struct {
	ID         int64     `db:"id"`
	Name       string    `db:"name"`
	CreatedAt  time.Time `db:"created_at"`
	IsAdmin    bool      `db:"is_admin"`
	CreatedBy  *int64    `db:"created_by"`
	TelegramID *int64    `db:"telegram_id"`
	SlackID    *string   `db:"slack_id"`
	LarkID     *string   `db:"lark_id"`
	APIToken   *string   `db:"api_token"`
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const eventsCreate = `-- name: EventsCreate :one
INSERT INTO events (uuid, payload_id, protocol, r, w, rw, meta, remote_addr,
  received_at, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, now())
RETURNING id, payload_id, protocol, rw, r, w, meta, remote_addr, received_at, created_at, uuid
`

type EventsCreateParams struct {
	UUID       uuid.UUID  `db:"uuid"`
	PayloadID  int64      `db:"payload_id"`
	Protocol   string     `db:"protocol"`
	R          []byte     `db:"r"`
	W          []byte     `db:"w"`
	RW         []byte     `db:"rw"`
	Meta       EventsMeta `db:"meta"`
	RemoteAddr string     `db:"remote_addr"`
	ReceivedAt time.Time  `db:"received_at"`
}

func (q *Queries) EventsCreate(ctx context.Context, arg EventsCreateParams) (*Event, error) {
	row := q.db.QueryRow(ctx, eventsCreate,
		arg.UUID,
		arg.PayloadID,
		arg.Protocol,
		arg.R,
		arg.W,
		arg.RW,
		arg.Meta,
		arg.RemoteAddr,
		arg.ReceivedAt,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.PayloadID,
		&i.Protocol,
		&i.RW,
		&i.R,
		&i.W,
		&i.Meta,
		&i.RemoteAddr,
		&i.ReceivedAt,
		&i.CreatedAt,
		&i.UUID,
	)
	return &i, err
}

const eventsGetByID = `-- name: EventsGetByID :one
SELECT id, payload_id, protocol, rw, r, w, meta, remote_addr, received_at, created_at, uuid FROM events WHERE id = $1
`

func (q *Queries) EventsGetByID(ctx context.Context, id int64) (*Event, error) {
	row := q.db.QueryRow(ctx, eventsGetByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.PayloadID,
		&i.Protocol,
		&i.RW,
		&i.R,
		&i.W,
		&i.Meta,
		&i.RemoteAddr,
		&i.ReceivedAt,
		&i.CreatedAt,
		&i.UUID,
	)
	return &i, err
}

const eventsGetByPayloadAndIndex = `-- name: EventsGetByPayloadAndIndex :one
WITH numbered AS (
  SELECT
    id,
    ROW_NUMBER() OVER (PARTITION BY payload_id ORDER BY id ASC) AS index
  FROM events
)
SELECT e.id, e.payload_id, e.protocol, e.rw, e.r, e.w, e.meta, e.remote_addr, e.received_at, e.created_at, e.uuid, n.index
FROM events e
JOIN numbered n ON n.id = e.id
WHERE e.payload_id = $1::bigint AND n.index = $2::bigint
`

type EventsGetByPayloadAndIndexRow struct {
	Event Event `db:"event"`
	Index int64 `db:"index"`
}

func (q *Queries) EventsGetByPayloadAndIndex(ctx context.Context, payloadID int64, index int64) (*EventsGetByPayloadAndIndexRow, error) {
	row := q.db.QueryRow(ctx, eventsGetByPayloadAndIndex, payloadID, index)
	var i EventsGetByPayloadAndIndexRow
	err := row.Scan(
		&i.Event.ID,
		&i.Event.PayloadID,
		&i.Event.Protocol,
		&i.Event.RW,
		&i.Event.R,
		&i.Event.W,
		&i.Event.Meta,
		&i.Event.RemoteAddr,
		&i.Event.ReceivedAt,
		&i.Event.CreatedAt,
		&i.Event.UUID,
		&i.Index,
	)
	return &i, err
}

const eventsListByPayloadID = `-- name: EventsListByPayloadID :many
SELECT 
  events.id, events.payload_id, events.protocol, events.rw, events.r, events.w, events.meta, events.remote_addr, events.received_at, events.created_at, events.uuid,
  ROW_NUMBER() OVER(PARTITION BY payload_id ORDER BY id ASC) AS index
FROM events WHERE payload_id = $1
ORDER BY id DESC
LIMIT $2
OFFSET $3
`

type EventsListByPayloadIDParams struct {
	PayloadID int64 `db:"payload_id"`
	Limit     int64 `db:"limit"`
	Offset    int64 `db:"offset"`
}

type EventsListByPayloadIDRow struct {
	Event Event `db:"event"`
	Index int64 `db:"index"`
}

func (q *Queries) EventsListByPayloadID(ctx context.Context, arg EventsListByPayloadIDParams) ([]*EventsListByPayloadIDRow, error) {
	rows, err := q.db.Query(ctx, eventsListByPayloadID, arg.PayloadID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EventsListByPayloadIDRow{}
	for rows.Next() {
		var i EventsListByPayloadIDRow
		if err := rows.Scan(
			&i.Event.ID,
			&i.Event.PayloadID,
			&i.Event.Protocol,
			&i.Event.RW,
			&i.Event.R,
			&i.Event.W,
			&i.Event.Meta,
			&i.Event.RemoteAddr,
			&i.Event.ReceivedAt,
			&i.Event.CreatedAt,
			&i.Event.UUID,
			&i.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

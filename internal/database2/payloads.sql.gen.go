// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payloads.sql

package database2

import (
	"context"
)

const payloadsCreate = `-- name: PayloadsCreate :one
INSERT INTO payloads (user_id, subdomain, name, notify_protocols, store_events, created_at)
VALUES ($1, $2, $3, $4, $5, now())
RETURNING id, user_id, subdomain, name, created_at, notify_protocols, store_events
`

type PayloadsCreateParams struct {
	UserID          int64    `db:"user_id"`
	Subdomain       string   `db:"subdomain"`
	Name            string   `db:"name"`
	NotifyProtocols []string `db:"notify_protocols"`
	StoreEvents     bool     `db:"store_events"`
}

func (q *Queries) PayloadsCreate(ctx context.Context, arg PayloadsCreateParams) (*Payload, error) {
	row := q.db.QueryRow(ctx, payloadsCreate,
		arg.UserID,
		arg.Subdomain,
		arg.Name,
		arg.NotifyProtocols,
		arg.StoreEvents,
	)
	var i Payload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subdomain,
		&i.Name,
		&i.CreatedAt,
		&i.NotifyProtocols,
		&i.StoreEvents,
	)
	return &i, err
}

const payloadsDelete = `-- name: PayloadsDelete :one
DELETE FROM payloads WHERE id = $1 RETURNING id, user_id, subdomain, name, created_at, notify_protocols, store_events
`

func (q *Queries) PayloadsDelete(ctx context.Context, id int64) (*Payload, error) {
	row := q.db.QueryRow(ctx, payloadsDelete, id)
	var i Payload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subdomain,
		&i.Name,
		&i.CreatedAt,
		&i.NotifyProtocols,
		&i.StoreEvents,
	)
	return &i, err
}

const payloadsDeleteByNamePart = `-- name: PayloadsDeleteByNamePart :many
DELETE FROM payloads WHERE user_id = $1 AND name ILIKE $2 RETURNING id, user_id, subdomain, name, created_at, notify_protocols, store_events
`

func (q *Queries) PayloadsDeleteByNamePart(ctx context.Context, userID int64, name string) ([]*Payload, error) {
	rows, err := q.db.Query(ctx, payloadsDeleteByNamePart, userID, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Payload{}
	for rows.Next() {
		var i Payload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Subdomain,
			&i.Name,
			&i.CreatedAt,
			&i.NotifyProtocols,
			&i.StoreEvents,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const payloadsFindByUserAndName = `-- name: PayloadsFindByUserAndName :many
SELECT id, user_id, subdomain, name, created_at, notify_protocols, store_events FROM payloads
WHERE user_id = $1 AND name ILIKE $2
ORDER BY id DESC LIMIT $3 OFFSET $4
`

type PayloadsFindByUserAndNameParams struct {
	UserID int64  `db:"user_id"`
	Name   string `db:"name"`
	Limit  int64  `db:"limit"`
	Offset int64  `db:"offset"`
}

func (q *Queries) PayloadsFindByUserAndName(ctx context.Context, arg PayloadsFindByUserAndNameParams) ([]*Payload, error) {
	rows, err := q.db.Query(ctx, payloadsFindByUserAndName,
		arg.UserID,
		arg.Name,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Payload{}
	for rows.Next() {
		var i Payload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Subdomain,
			&i.Name,
			&i.CreatedAt,
			&i.NotifyProtocols,
			&i.StoreEvents,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const payloadsFindByUserID = `-- name: PayloadsFindByUserID :many
SELECT id, user_id, subdomain, name, created_at, notify_protocols, store_events FROM payloads WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) PayloadsFindByUserID(ctx context.Context, userID int64) ([]*Payload, error) {
	rows, err := q.db.Query(ctx, payloadsFindByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Payload{}
	for rows.Next() {
		var i Payload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Subdomain,
			&i.Name,
			&i.CreatedAt,
			&i.NotifyProtocols,
			&i.StoreEvents,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const payloadsGetAllSubdomains = `-- name: PayloadsGetAllSubdomains :many
SELECT subdomain FROM payloads
`

func (q *Queries) PayloadsGetAllSubdomains(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, payloadsGetAllSubdomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var subdomain string
		if err := rows.Scan(&subdomain); err != nil {
			return nil, err
		}
		items = append(items, subdomain)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const payloadsGetByID = `-- name: PayloadsGetByID :one
SELECT id, user_id, subdomain, name, created_at, notify_protocols, store_events FROM payloads WHERE id = $1
`

func (q *Queries) PayloadsGetByID(ctx context.Context, id int64) (*Payload, error) {
	row := q.db.QueryRow(ctx, payloadsGetByID, id)
	var i Payload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subdomain,
		&i.Name,
		&i.CreatedAt,
		&i.NotifyProtocols,
		&i.StoreEvents,
	)
	return &i, err
}

const payloadsGetBySubdomain = `-- name: PayloadsGetBySubdomain :one
SELECT id, user_id, subdomain, name, created_at, notify_protocols, store_events FROM payloads WHERE subdomain = $1
`

func (q *Queries) PayloadsGetBySubdomain(ctx context.Context, subdomain string) (*Payload, error) {
	row := q.db.QueryRow(ctx, payloadsGetBySubdomain, subdomain)
	var i Payload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subdomain,
		&i.Name,
		&i.CreatedAt,
		&i.NotifyProtocols,
		&i.StoreEvents,
	)
	return &i, err
}

const payloadsGetByUserAndName = `-- name: PayloadsGetByUserAndName :one
SELECT id, user_id, subdomain, name, created_at, notify_protocols, store_events FROM payloads WHERE user_id = $1 AND name = $2
`

func (q *Queries) PayloadsGetByUserAndName(ctx context.Context, userID int64, name string) (*Payload, error) {
	row := q.db.QueryRow(ctx, payloadsGetByUserAndName, userID, name)
	var i Payload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subdomain,
		&i.Name,
		&i.CreatedAt,
		&i.NotifyProtocols,
		&i.StoreEvents,
	)
	return &i, err
}

const payloadsUpdate = `-- name: PayloadsUpdate :one
UPDATE payloads SET
  subdomain = $2,
  user_id = $3,
  name = $4,
  notify_protocols = $5,
  store_events = $6
WHERE id = $1
RETURNING id, user_id, subdomain, name, created_at, notify_protocols, store_events
`

type PayloadsUpdateParams struct {
	ID              int64    `db:"id"`
	Subdomain       string   `db:"subdomain"`
	UserID          int64    `db:"user_id"`
	Name            string   `db:"name"`
	NotifyProtocols []string `db:"notify_protocols"`
	StoreEvents     bool     `db:"store_events"`
}

func (q *Queries) PayloadsUpdate(ctx context.Context, arg PayloadsUpdateParams) (*Payload, error) {
	row := q.db.QueryRow(ctx, payloadsUpdate,
		arg.ID,
		arg.Subdomain,
		arg.UserID,
		arg.Name,
		arg.NotifyProtocols,
		arg.StoreEvents,
	)
	var i Payload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subdomain,
		&i.Name,
		&i.CreatedAt,
		&i.NotifyProtocols,
		&i.StoreEvents,
	)
	return &i, err
}

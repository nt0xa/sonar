// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dns_records.sql

package database2

import (
	"context"
	"time"
)

const dNSRecordsCreate = `-- name: DNSRecordsCreate :one
INSERT INTO dns_records (payload_id, name, type, ttl, values, strategy,
  last_answer, last_accessed_at, created_at, index)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, now(),
  (SELECT COALESCE(MAX(index), 0) FROM dns_records dr WHERE dr.payload_id = $1) + 1)
RETURNING id, payload_id, name, type, ttl, values, strategy, last_answer, last_accessed_at, created_at, index
`

type DNSRecordsCreateParams struct {
	PayloadID      int64         `db:"payload_id"`
	Name           string        `db:"name"`
	Type           DNSRecordType `db:"type"`
	TTL            int32         `db:"ttl"`
	Values         []string      `db:"values"`
	Strategy       DNSStrategy   `db:"strategy"`
	LastAnswer     []string      `db:"last_answer"`
	LastAccessedAt *time.Time    `db:"last_accessed_at"`
}

func (q *Queries) DNSRecordsCreate(ctx context.Context, arg DNSRecordsCreateParams) (*DNSRecord, error) {
	row := q.db.QueryRow(ctx, dNSRecordsCreate,
		arg.PayloadID,
		arg.Name,
		arg.Type,
		arg.TTL,
		arg.Values,
		arg.Strategy,
		arg.LastAnswer,
		arg.LastAccessedAt,
	)
	var i DNSRecord
	err := row.Scan(
		&i.ID,
		&i.PayloadID,
		&i.Name,
		&i.Type,
		&i.TTL,
		&i.Values,
		&i.Strategy,
		&i.LastAnswer,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.Index,
	)
	return &i, err
}

const dNSRecordsDelete = `-- name: DNSRecordsDelete :exec
DELETE FROM dns_records WHERE id = $1
`

func (q *Queries) DNSRecordsDelete(ctx context.Context, id *int64) error {
	_, err := q.db.Exec(ctx, dNSRecordsDelete, id)
	return err
}

const dNSRecordsDeleteAllByPayloadID = `-- name: DNSRecordsDeleteAllByPayloadID :many
DELETE FROM dns_records WHERE payload_id = $1 RETURNING id, payload_id, name, type, ttl, values, strategy, last_answer, last_accessed_at, created_at, index
`

func (q *Queries) DNSRecordsDeleteAllByPayloadID(ctx context.Context, payloadID int64) ([]*DNSRecord, error) {
	rows, err := q.db.Query(ctx, dNSRecordsDeleteAllByPayloadID, payloadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DNSRecord{}
	for rows.Next() {
		var i DNSRecord
		if err := rows.Scan(
			&i.ID,
			&i.PayloadID,
			&i.Name,
			&i.Type,
			&i.TTL,
			&i.Values,
			&i.Strategy,
			&i.LastAnswer,
			&i.LastAccessedAt,
			&i.CreatedAt,
			&i.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dNSRecordsDeleteAllByPayloadIDAndName = `-- name: DNSRecordsDeleteAllByPayloadIDAndName :many
DELETE FROM dns_records WHERE payload_id = $1 AND name = $2 RETURNING id, payload_id, name, type, ttl, values, strategy, last_answer, last_accessed_at, created_at, index
`

func (q *Queries) DNSRecordsDeleteAllByPayloadIDAndName(ctx context.Context, payloadID int64, name string) ([]*DNSRecord, error) {
	rows, err := q.db.Query(ctx, dNSRecordsDeleteAllByPayloadIDAndName, payloadID, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DNSRecord{}
	for rows.Next() {
		var i DNSRecord
		if err := rows.Scan(
			&i.ID,
			&i.PayloadID,
			&i.Name,
			&i.Type,
			&i.TTL,
			&i.Values,
			&i.Strategy,
			&i.LastAnswer,
			&i.LastAccessedAt,
			&i.CreatedAt,
			&i.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dNSRecordsGetByID = `-- name: DNSRecordsGetByID :one
SELECT id, payload_id, name, type, ttl, values, strategy, last_answer, last_accessed_at, created_at, index FROM dns_records WHERE id = $1
`

func (q *Queries) DNSRecordsGetByID(ctx context.Context, id *int64) (*DNSRecord, error) {
	row := q.db.QueryRow(ctx, dNSRecordsGetByID, id)
	var i DNSRecord
	err := row.Scan(
		&i.ID,
		&i.PayloadID,
		&i.Name,
		&i.Type,
		&i.TTL,
		&i.Values,
		&i.Strategy,
		&i.LastAnswer,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.Index,
	)
	return &i, err
}

const dNSRecordsGetByPayloadID = `-- name: DNSRecordsGetByPayloadID :many
SELECT id, payload_id, name, type, ttl, values, strategy, last_answer, last_accessed_at, created_at, index FROM dns_records WHERE payload_id = $1 ORDER BY id ASC
`

func (q *Queries) DNSRecordsGetByPayloadID(ctx context.Context, payloadID int64) ([]*DNSRecord, error) {
	rows, err := q.db.Query(ctx, dNSRecordsGetByPayloadID, payloadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DNSRecord{}
	for rows.Next() {
		var i DNSRecord
		if err := rows.Scan(
			&i.ID,
			&i.PayloadID,
			&i.Name,
			&i.Type,
			&i.TTL,
			&i.Values,
			&i.Strategy,
			&i.LastAnswer,
			&i.LastAccessedAt,
			&i.CreatedAt,
			&i.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dNSRecordsGetByPayloadIDAndIndex = `-- name: DNSRecordsGetByPayloadIDAndIndex :one
SELECT id, payload_id, name, type, ttl, values, strategy, last_answer, last_accessed_at, created_at, index FROM dns_records WHERE payload_id = $1 AND index = $2
`

func (q *Queries) DNSRecordsGetByPayloadIDAndIndex(ctx context.Context, payloadID int64, index int32) (*DNSRecord, error) {
	row := q.db.QueryRow(ctx, dNSRecordsGetByPayloadIDAndIndex, payloadID, index)
	var i DNSRecord
	err := row.Scan(
		&i.ID,
		&i.PayloadID,
		&i.Name,
		&i.Type,
		&i.TTL,
		&i.Values,
		&i.Strategy,
		&i.LastAnswer,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.Index,
	)
	return &i, err
}

const dNSRecordsGetByPayloadNameAndType = `-- name: DNSRecordsGetByPayloadNameAndType :one
SELECT id, payload_id, name, type, ttl, values, strategy, last_answer, last_accessed_at, created_at, index FROM dns_records
WHERE payload_id = $1 AND name = $2 AND type = $3
`

type DNSRecordsGetByPayloadNameAndTypeParams struct {
	PayloadID int64         `db:"payload_id"`
	Name      string        `db:"name"`
	Type      DNSRecordType `db:"type"`
}

func (q *Queries) DNSRecordsGetByPayloadNameAndType(ctx context.Context, arg DNSRecordsGetByPayloadNameAndTypeParams) (*DNSRecord, error) {
	row := q.db.QueryRow(ctx, dNSRecordsGetByPayloadNameAndType, arg.PayloadID, arg.Name, arg.Type)
	var i DNSRecord
	err := row.Scan(
		&i.ID,
		&i.PayloadID,
		&i.Name,
		&i.Type,
		&i.TTL,
		&i.Values,
		&i.Strategy,
		&i.LastAnswer,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.Index,
	)
	return &i, err
}

const dNSRecordsGetCountByPayloadID = `-- name: DNSRecordsGetCountByPayloadID :one
SELECT COUNT(*) FROM dns_records WHERE payload_id = $1
`

func (q *Queries) DNSRecordsGetCountByPayloadID(ctx context.Context, payloadID int64) (int64, error) {
	row := q.db.QueryRow(ctx, dNSRecordsGetCountByPayloadID, payloadID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const dNSRecordsUpdate = `-- name: DNSRecordsUpdate :one
UPDATE dns_records SET
  payload_id = $2,
  name = $3,
  type = $4,
  ttl = $5,
  values = $6,
  strategy = $7,
  last_answer = $8,
  last_accessed_at = $9
WHERE id = $1
RETURNING id, payload_id, name, type, ttl, values, strategy, last_answer, last_accessed_at, created_at, index
`

type DNSRecordsUpdateParams struct {
	ID             *int64        `db:"id"`
	PayloadID      int64         `db:"payload_id"`
	Name           string        `db:"name"`
	Type           DNSRecordType `db:"type"`
	TTL            int32         `db:"ttl"`
	Values         []string      `db:"values"`
	Strategy       DNSStrategy   `db:"strategy"`
	LastAnswer     []string      `db:"last_answer"`
	LastAccessedAt *time.Time    `db:"last_accessed_at"`
}

func (q *Queries) DNSRecordsUpdate(ctx context.Context, arg DNSRecordsUpdateParams) (*DNSRecord, error) {
	row := q.db.QueryRow(ctx, dNSRecordsUpdate,
		arg.ID,
		arg.PayloadID,
		arg.Name,
		arg.Type,
		arg.TTL,
		arg.Values,
		arg.Strategy,
		arg.LastAnswer,
		arg.LastAccessedAt,
	)
	var i DNSRecord
	err := row.Scan(
		&i.ID,
		&i.PayloadID,
		&i.Name,
		&i.Type,
		&i.TTL,
		&i.Values,
		&i.Strategy,
		&i.LastAnswer,
		&i.LastAccessedAt,
		&i.CreatedAt,
		&i.Index,
	)
	return &i, err
}
